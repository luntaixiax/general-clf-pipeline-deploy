from datetime import date, datetime, timezone
import pymongo
import yaml
import json
from pathlib import Path
from luntaiDs.ProviderTools.mongo.serving import _BaseModelRegistryMongo
from luntaiDs.ProviderTools.mongo.serving import ModelTimeTableMongo
from src.data_connection import Connection
from src.model import FakeLinearProbModel

class FakeModelRegistryMongo(_BaseModelRegistryMongo):
    def delete_model_files(self, model_id: str):
        """delete model related files/data

        :param str model_id: model id to be deleted
        """
        collection = self._mongo[self.db]['models'] # save to collection `models`
        collection.delete_one(
            {
                'model_id': model_id
            }, # find matching record, if any
        )

    def load_model_by_config(self, config: dict) -> FakeLinearProbModel:
        """load the model using configuration file

        :param dict config: configuration for the model
        """
        model_id = config['model_id']
        db = config.get('db', self.db)
        collect = config.get('collection', 'models')
        collection = self._mongo[db][collect]
        record = (
            collection
            .find_one(
                {'model_id': model_id}, # matching condition
                {'_id': 0, 'feature_profile' : 1, 'model_coeffs' : 1}, # drop id column
                sort = [( '_id', pymongo.DESCENDING )] # in case multiple, find the latest record
            )
        )
        return FakeLinearProbModel(
            profile = record['feature_profile'],
            model_coeffs = record['model_coeffs']
        )

    def save_model_and_generate_config(self, model_id:str, feature_profile: dict, model_coeffs: dict, description: str = None) -> dict:
        """save model and generate configuration for this model

        :param str model_id: model id to be generated
        :param dict feature_profile: feature profiling report
        :param dict model_coeffs: model coefficients
        :param str description: description of the model
        :return dict: the configuration generated by creating model into the system
        """
        # save feature profile and model coefficients
        content = {
            'model_id' : model_id,
            'feature_profile' : feature_profile,
            'model_coeffs' : model_coeffs
        }
        collection = self._mongo[self.db]['models'] # save to collection `models`
        collection.replace_one(
            filter = {
                'model_id': model_id
            }, # find matching record, if any
            replacement = content,
            upsert = True # update if found, insert if not found
        )
        return {
            'model_id' : model_id,
            'db' : self.db,
            'collection' : 'models',
            'last_update_ts' : datetime.now(timezone.utc),
            'description' : description
        }
        

MODEL_PATHS = {
    'event' : 'data/event',
    'conversion' : 'data/conversion'
}

def register_predefined_fake_models(model_name: str):
    # model registry
    frm = FakeModelRegistryMongo(
        mongo_client = Connection().MONGO,
        db = 'fake',
        collection = f'model_registry_{model_name}'
    )
    # model timetable
    mtb = ModelTimeTableMongo(
        mongo_client = Connection().MONGO,
        db = 'fake',
        collection = f'time_table_{model_name}'
    )
    
    model_root_path = MODEL_PATHS[model_name]
    # load feature profling json
    with open(Path(model_root_path) / 'feature_standalone_profile.json') as obj:
        feature_profile = json.load(obj)
    
    # load model coefficients with drifts (different versions)
    with open(Path(model_root_path) / 'drifts' / 'metadata.yml') as obj:
        metadata = yaml.safe_load(obj).get('models', {})
    
    for model_id, meta in metadata.items():
        coeff_file_path = Path(model_root_path) / 'drifts' / meta['jspath']
        with open(coeff_file_path) as obj:
            model_coeffs = json.load(obj)
        
        # register model
        try:
            frm.register(
                model_id = model_id,
                feature_profile = feature_profile,
                model_coeffs = model_coeffs,
                description = meta['description']
            )
        except AssertionError as e:
            pass
        
        # register to timetable
        effective_weeks = meta['effective_weeks']
        for week in effective_weeks:
            start = datetime.fromordinal(date.fromisocalendar(2024, week, 1).toordinal())
            end = datetime.fromordinal(date.fromisocalendar(2024, week, 7).toordinal())
            mtb.register(model_id, start, end, force = True)

def load_fake_model_by_timetable(model_name: str, snap_dt: date) -> FakeLinearProbModel:
    # model timetable
    mtb = ModelTimeTableMongo(
        mongo_client = Connection().MONGO,
        db = 'fake',
        collection = f'time_table_{model_name}'
    )
    
    model_id = mtb.get_model_id_by_datetime(
        datetime.fromordinal(snap_dt.toordinal())
    )
    if model_id is None:
        # load default model id
        # load model coefficients with drifts (different versions)
        model_root_path = MODEL_PATHS[model_name]
        with open(Path(model_root_path) / 'drifts' / 'metadata.yml') as obj:
            metadata = yaml.safe_load(obj).get('models', {})
            return metadata['default_model']
    else:
        # model registry
        frm = FakeModelRegistryMongo(
            mongo_client = Connection().MONGO,
            db = 'fake',
            collection = f'model_registry_{model_name}'
        )
        return frm.load_model(model_id = model_id)